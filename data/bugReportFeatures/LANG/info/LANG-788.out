{
	"desc":"\n\nIf a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.\n\nimport org.apache.commons.lang3.SerializationUtils;\nimport org.junit.Test;\n\n\npublic class SerializationUtilsTest {\n\n	\n	@Test\n	public void primitiveTypeClassSerialization(){\n		Class<?> primitiveType = int.class;\n		\n		Class<?> clone = SerializationUtils.clone(primitiveType);\n		assertEquals(primitiveType, clone);\n	}\n}\n\n\nThe problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4.\nThe SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's\nresoleClass method without delegating to the super method in case of a ClassNotFoundException.\nI understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation.\nFor example:\n\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n            String name = desc.getName();\n            try {\n                return Class.forName(name, false, classLoader);\n            } catch (ClassNotFoundException ex) {\n            	try {\n            	     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n            	} catch (Exception e) {\n		     return super.resolveClass(desc);\n		}\n            }\n        }\n\n\nHere is the code in ObjectInputStream that fixed the java bug.\n\n    protected Class<?> resolveClass(ObjectStreamClass desc)\n	throws IOException, ClassNotFoundException\n    {\n	String name = desc.getName();\n	try {\n	    return Class.forName(name, false, latestUserDefinedLoader());\n	} catch (ClassNotFoundException ex) {\n	    Class cl = (Class) primClasses.get(name);\n	    if (cl != null) {\n		return cl;\n	    } else {\n		throw ex;\n	    }\n	}\n    }\n\n\n\n", 
	"remain":"\n\nIf a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.\n\n\n\npublic class SerializationUtilsTest {\n\n	\n	public void primitiveTypeClassSerialization(){\n		\n		assertEquals(primitiveType, clone);\n}\n\n\nThe problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4.\nThe SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's\nresoleClass method without delegating to the super method in case of a ClassNotFoundException.\nI understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation.\nFor example:\n\n            String name = desc.getName();\n                return Class.forName(name, false, classLoader);\n            	try {\n            	} catch (Exception e) {\n            }\n        }\n\n\nHere is the code in ObjectInputStream that fixed the java bug.\n\n    protected Class<?> resolveClass(ObjectStreamClass desc)\n	throws IOException, ClassNotFoundException\n    {\n	try {\n	    return Class.forName(name, false, latestUserDefinedLoader());\n	    Class cl = (Class) primClasses.get(name);\n		return cl;\n		throw ex;\n	}\n    }\n", 
	"source":"import org.apache.commons.lang3.SerializationUtils;\nimport org.junit.Test;\npublic class SerializationUtilsTest {\n\n	\n	@Test\n	public void primitiveTypeClassSerialization(){\n		Class<?> primitiveType = int.class;\n		\n		Class<?> clone = SerializationUtils.clone(primitiveType);\n		assertEquals(primitiveType, clone);\n	}\n}\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n            String name = desc.getName();\n            try {\n                return Class.forName(name, false, classLoader);\n            } catch (ClassNotFoundException ex) {\n            	try {\n            	     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n            	} catch (Exception e) {\n		     return super.resolveClass(desc);\n		}\n            }\n        }\n	String name = desc.getName();\n	    return Class.forName(name, false, latestUserDefinedLoader());\n	} catch (ClassNotFoundException ex) {\n	    Class cl = (Class) primClasses.get(name);\n	    if (cl != null) {\n		return cl;\n	    } else {\n		throw ex;\n	    }\n	}", 
	"talks":"", 
	"traces":[], 
	"enums":[]}