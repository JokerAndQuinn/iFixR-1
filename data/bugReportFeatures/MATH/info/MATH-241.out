{
	"desc":"\n\nProbably due to rounding errors, MathUtils.binomialCoefficient(n,k) fails for results near Long.MAX_VALUE.\nThe existence of failures can be demonstrated by testing the recursive property:\n\n         assertEquals(MathUtils.binomialCoefficient(65,32) + MathUtils.binomialCoefficient(65,33),\n                 MathUtils.binomialCoefficient(66,33));\n\n\nOr by directly using the (externally calculated and hopefully correct) expected value:\n\n         assertEquals(7219428434016265740L, MathUtils.binomialCoefficient(66,33));\n\n\nI suggest a nonrecursive test implementation along the lines of\nMathUtilsTest.java\n    /**\n     * Exact implementation using BigInteger and the explicit formula\n     * (n, k) == ((k-1)*...*n) / (1*...*(n-k))\n     */\n	public static long binomialCoefficient(int n, int k) {\n		if (k == 0 || k == n)\n			return 1;\n		BigInteger result = BigInteger.ONE;\n		for (int i = k + 1; i <= n; i++) {\n			result = result.multiply(BigInteger.valueOf(i));\n		}\n		for (int i = 1; i <= n - k; i++) {\n			result = result.divide(BigInteger.valueOf(i));\n		}\n		if (result.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n			throw new ArithmeticException(\n                                \"Binomial coefficient overflow: \" + n + \", \" + k);\n		}\n		return result.longValue();\n	}\n\n\nWhich would allow you to test the expected values directly:\n\n         assertEquals(binomialCoefficient(66,33), MathUtils.binomialCoefficient(66,33));\n\n\n\n", 
	"remain":"\n\nProbably due to rounding errors, MathUtils.binomialCoefficient(n,k) fails for results near Long.MAX_VALUE.\nThe existence of failures can be demonstrated by testing the recursive property:\n\n         assertEquals(MathUtils.binomialCoefficient(65,32) + MathUtils.binomialCoefficient(65,33),\n\n\nOr by directly using the (externally calculated and hopefully correct) expected value:\n\n\n\nI suggest a nonrecursive test implementation along the lines of\nMathUtilsTest.java\n    /**\n     * (n, k) == ((k-1)*...*n) / (1*...*(n-k))\n	public static long binomialCoefficient(int n, int k) {\n			return 1;\n		for (int i = k + 1; i <= n; i++) {\n		}\n			result = result.divide(BigInteger.valueOf(i));\n		if (result.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n                                \"Binomial coefficient overflow: \" + n + \", \" + k);\n		return result.longValue();\n\n\nWhich would allow you to test the expected values directly:\n\n         assertEquals(binomialCoefficient(66,33), MathUtils.binomialCoefficient(66,33));\n", 
	"source":"MathUtils.binomialCoefficient(66,33));\n         assertEquals(7219428434016265740L, MathUtils.binomialCoefficient(66,33));\n    /**\n     * Exact implementation using BigInteger and the explicit formula\n     * (n, k) == ((k-1)*...*n) / (1*...*(n-k))\n     */\n	public static long binomialCoefficient(int n, int k) {\n		if (k == 0 || k == n)\n			return 1;\n		BigInteger result = BigInteger.ONE;\n		for (int i = k + 1; i <= n; i++) {\n			result = result.multiply(BigInteger.valueOf(i));\n		}\n		for (int i = 1; i <= n - k; i++) {\n			result = result.divide(BigInteger.valueOf(i));\n		}\n		if (result.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n			throw new ArithmeticException(\n                                \"Binomial coefficient overflow: \" + n + \", \" + k);\n		}\n		return result.longValue();\n	}\n         assertEquals(binomialCoefficient(66,33), MathUtils.binomialCoefficient(66,33));", 
	"talks":"", 
	"traces":[], 
	"enums":[]}